# LAD-IMPL-014 / T014-00 链接点击修复方案

> 版本：v1（设计稿）  
> 所属任务：LAD-IMPL-014（链接处理与预览体验）  
> 子任务编号：T014-00「链接点击基础链路修复」
> 实现状态（local_markdown_viewer_app）：已在 ContentViewer + LinkProcessor 中按 T014-00 完成「链接点击基础链路修复」；其余预览、指标与诊断扩展在本仓库暂不落地，留待后续 014/015 任务。  

---

## 1. 背景与问题描述

### 1.1 现象

- 在本地运行主应用时，打开 `LAD_Project/README.md`，日志显示：
  - `core.markdown_renderer` 正常工作；
  - `ui.content_viewer` 记录 `本次渲染HTML包含链接数: N`；
  - 状态栏提示 README 已加载完成。
- 但用户在界面中点击 README 内任意链接：
  - **界面无跳转行为**（不切换文件、不滚动至锚点、不打开外部浏览器）；
  - 日志中 **没有** 预期的导航日志，例如：
    - `NAV|click_href=...`；
    - `NAV|resolved_target=...`；
    - `NAV|open_file|from=...|to=...`；
    - 「已打开外部链接 / 已跳转到锚点 / 链接错误」等状态更新。

### 1.2 期望行为

- 对 README 及其它 Markdown 内所有 `<a>` 链接：
  - 点击后应统一交由 `LinkProcessor` 决策；
  - 根据链接类型（外链、相对 Markdown、目录、锚点、文件协议等）执行对应动作：
    - 在文档树中打开 Markdown / 目录（优先生找 README）；
    - 在系统浏览器中打开外链；
    - 在当前预览中滚动至锚点；
  - 日志中应可观测到完整的链路：
    - `NAV|click_href=...`；
    - `NAV|resolved_target=...`；
    - `NAV|open_file/open_directory/open_external/scroll_to_anchor` 等。

### 1.3 现有测试与调试现状

- 单元 / 集成测试：
  - `tests/test_content_viewer_integration.py` 等测试 **直接调用** `ContentViewer.handle_link_click(...)` / `handle_image_click(...)`：
    - 覆盖「给定 link_info → LinkProcessor / UI 动作是否正确」；
    - **不覆盖**「QWebEngine 中用户点击 `<a>` → JS/console → Python 的事件链路」。
  - `tests/test_link_processor_misc.py` 等测试直接面向 `LinkProcessor`：
    - 覆盖 ANCHOR / TOC / 相对路径等解析逻辑；
    - 同样**不涉及 GUI 点击链路**。
- 独立调试脚本：
  - `tests/tools/link_debug_readme.py` 在单独窗口中：
    - 渲染指定 Markdown；
    - 通过自定义 `InterceptingPage` + JS 注入拦截点击；
    - 调用 `LinkProcessor` 并执行导航；
  - 在该脚本下，点击 `LAD_Project/README.md` 内链接行为**正常**。

**结论：**

- core 层（`ContentPreview` + `LinkProcessor`）在调试器环境下工作正常；
- 主应用中的 bug 集中在：
  - **QWebEngine 内部点击事件 → JS/console → `_CVPage` → `ContentViewer._handle_lpclick` 这条 wiring 被中断或不可靠；**
- 现有自动化测试对 GUI 点击链路完全缺失覆盖，因此无法捕捉此类问题。

---

## 2. 目标与非目标

### 2.1 设计目标

- **G1：链路打通**  
  主应用中，从 HTML `<a>` 点击到导航行为，形成完整、可观测的链路：

  ```text
  用户点击 <a>
    → QWebEngine 触发导航 / JS 点击事件
    → _CVPage 拦截（acceptNavigationRequest / javaScriptConsoleMessage）
    → ContentViewer._handle_lpclick(href)
    → LinkProcessor.process_link(ctx)
    → ContentViewer._execute_link_action(result)
    → UI / 日志表现出对应导航动作
  ```

- **G2：行为与调试脚本对齐**  
  主应用在「链接点击 → LinkProcessor → 导航」上的行为，与 `tests/tools/link_debug_readme.py` 尽量保持语义一致，仅在日志前缀等细节上有所区分。

- **G3：对现有核心模块无破坏性修改**  
  不改变以下对象的外部接口与既有语义：
  - `LinkProcessor` 及各类 `Handler`；
  - `ContentViewer.handle_link_click`（供现有单测和外部调用使用）。

- **G4：最小必要回归覆盖**  
  在不依赖完整 GUI 环境的前提下，增加针对 wiring 的最小单测，防止后续 refactor 再次断开链路。

### 2.2 非目标

- 不在 T014-00 中：
  - 调整 `LinkProcessor` 行为策略、配置项或错误码体系；
  - 引入新的诊断数据源或 integration.qa 报告结构变更；
  - 处理所有可能的 HTML/JS 复杂交互场景（例如页面内 SPA 路由等）。

---

## 3. 现有架构简要回顾

### 3.1 ContentViewer 链接处理链路（当前设计）

1. `_display_html(html_content)`：
   - 统计 `<a>` 标签数量并记录日志 `本次渲染HTML包含链接数: N`；
   - 调用 `QWebEngineView.setHtml(html_content, base_url)` 进行渲染。
2. `_setup_connections()`：
   - 连接 `loadStarted` / `loadProgress` / `loadFinished` 信号至对应槽。
3. `_on_load_finished(success)`：
   - 成功时转发到 `_on_page_load_finished(success)`。
4. `_on_page_load_finished(True)`：
   - 通过 `runJavaScript` 注入 JS 脚本，在页面加载完成后：
     - 注册全局 `document.addEventListener('click', ...)` 捕获器；
     - 在 handler 内通过 `closest('a')` 获取 `<a>`，调用 `console.log('LPCLICK:' + href)`。
   - 之后断开 `loadFinished` 信号，以避免重复注入。
5. `_CVPage.javaScriptConsoleMessage(...)`：
   - 委托 `ContentViewer._on_js_console_message(...)` 做日志；
   - 检测 `message.startswith("LPCLICK:")` 时，提取 href，调用 `ContentViewer._handle_lpclick(href)`。
6. `_handle_lpclick(href)`：
   - 构造 `LinkContext`，调用 `link_processor.process_link(ctx)`；
   - 日志记录 `NAV|click_href=...`、`NAV|resolved_target=...`；
   - 调 `_execute_link_action(result)` 执行 UI 导航动作。

### 3.2 link_debug_readme 链接处理链路（对照）

1. 使用 `ContentPreview.preview_file()` 渲染目标 Markdown，统计并打印链接列表；
2. 自定义 `InterceptingPage(QWebEnginePage)`：
   - 重写 `acceptNavigationRequest`：
     - 对 `NavigationTypeLinkClicked` 或 `lpdebug://` scheme 统一调用 `_on_link_clicked(url)`；
   - 重写 `javaScriptConsoleMessage`：
     - 打印所有 JS console 输出；
     - 检测 `LPCLICK:` 前缀并调用 `_on_link_clicked(QUrl(href))`。
3. `LinkDebugger._on_load_finished` 中注入 per-`<a>` JS：
   - 遍历所有 `a[href]`，为每个 `a` 单独绑定 `click` 监听器：
     - `ev.preventDefault()`；
     - 获取 `href`，`console.log('LPCLICK:' + href)`。
4. `_on_link_clicked(url)`：
   - 构造 `LinkContext`，调用 `LinkProcessor.process_link(ctx)`；
   - 将 `result` 打印，并通过 `_perform_action(result)` 执行导航。

**对照结论：**

- 调试脚本拥有「JS + LPCLICK」与「acceptNavigationRequest」两条通路；
- ContentViewer 当前仅依赖「JS + LPCLICK」一条通路，一旦 JS 注入或 console 回调出现问题，点击行为即被“吞掉”。

---

## 4. 设计方案：双通道拦截 + 对齐调试脚本

### 4.1 方案概览

- 在 `_CVPage`（主应用使用的自定义 QWebEnginePage）中：
  - 新增对 `acceptNavigationRequest` 的重写，拦截所有用户发起的链接导航请求；
  - 继续保留 `javaScriptConsoleMessage` 中的 `LPCLICK` 检测逻辑。
- 在 `ContentViewer._on_page_load_finished` 中：
  - 将现有的全局 `document` 捕获脚本，调整为与 `link_debug_readme` 风格一致的 per-`<a>` JS 绑定；
  - 使用不同日志前缀（如 `lpviewer:`）以便区分来源。
- 在 `_on_js_console_message` 中：
  - 增强日志可观测性，但不改变控制流；
- 保持 `_handle_lpclick` / `_execute_link_action` 的外部语义稳定。

整体思路：

> **JS + LPCLICK 作为“增强信道”，`acceptNavigationRequest` 作为“兜底信道”，共同确保任意 `<a>` 点击都能到达 `LinkProcessor`。**

### 4.2 `_CVPage.acceptNavigationRequest` 设计

#### 4.2.1 行为定义

- 在 `_WEBENGINE_AVAILABLE` 为 True 时：

  - 在 `_CVPage(QWebEnginePage)` 中新增：
    - `acceptNavigationRequest(self, url, nav_type, isMainFrame)`：
      - 若 `nav_type == QWebEnginePage.NavigationTypeLinkClicked`：
        - 获取 `href = url.toString()`；
        - 若 `href` 非空，调用 `self._owner._handle_lpclick(href)`；
        - 返回 `False`，阻止 WebView 自行导航；
      - 否则，调用 `super().acceptNavigationRequest(url, nav_type, isMainFrame)` 保持默认行为。

- 在 `_WEBENGINE_AVAILABLE` 为 False（测试 stub）时：

  - 在 `_CVPage(object)` 中提供同名方法：
    - 接收 `url/nav_type/isMainFrame` 参数；
    - 判断 nav_type 是否代表「链接点击」，如是，则以 `str(url)` 为 href 调用 `self._owner._handle_lpclick`；
    - 返回 `False`；
  - 便于在无 GUI 环境下对 wiring 做单元测试验证。

#### 4.2.2 设计理由

- 完全对齐 `tests/tools/link_debug_readme.InterceptingPage.acceptNavigationRequest` 的设计原则：
  - 所有用户发起的 link click 导航都不直接交给 WebView 自己处理；
  - 而是统一转交上层（这里是 `ContentViewer._handle_lpclick`），由 `LinkProcessor` 决策。
- 即便 JS 注入失败、`LPCLICK` 未触发，`acceptNavigationRequest` 仍可保障基本行为不丢失。

### 4.3 JS 注入逻辑对齐 `link_debug_readme`

#### 4.3.1 调整思路

- 保持 `_on_page_load_finished(success)` 的整体结构不变：
  - 仅在 `success is True` 时注入 JS；
  - 注入后断开 `loadFinished` 信号，避免重复注入。

- 将现有的 document 级捕获脚本收敛为 per-`<a>` 绑定：
  - 使用 `document.querySelectorAll('a[href]')` 获取所有链接元素；
  - 对每个 `a` 单独注册 `click` 监听器（捕获阶段或冒泡阶段均可，但建议保持与调试脚本一致的捕获阶段）：
    - `ev.preventDefault()`；
    - 从 `a.getAttribute('href') || ''` 读取 href：
      - 若 href 为空则直接返回；
    - 调用 `console.log('LPCLICK:' + href)`；
    - 返回 `false`。

- 为区分主应用与调试脚本，在 JS 中可使用不同日志前缀：
  - 如 `console.log('lpviewer: handlers attached count=' + anchors.length);`。

#### 4.3.2 好处

- 行为与 `link_debug_readme._on_load_finished` 高度一致，减少行为分叉；
- 若后续要排查链接点击问题，只需调试一套 JS 逻辑即可。

### 4.4 `_on_js_console_message` 的可观测性增强

#### 4.4.1 现状

- `_on_js_console_message` 目前主要做简单日志映射：
  - 根据 level 映射到 `debug` / `info` / `warning` 等等级；
  - 不参与实际控制流。

#### 4.4.2 调整建议

- 在不改变控制流的前提下，增加针对关键前缀的结构化日志：
  - 当 message 包含：
    - `lpviewer:`、`link-debugger:`、`LPCLICK:` 等前缀时：
      - 以统一格式记录，如 `JS|msg=...|src=...`；
      - 便于通过 grep/集成日志系统快速判断：
        - JS 是否被注入；
        - 链接点击是否被前端脚本观察到。

### 4.5 保持 `_handle_lpclick` / `_execute_link_action` 语义稳定

- `_handle_lpclick(href)`：
  - 保持现有行为：
    - 构造 `LinkContext(href=current, current_file, current_dir, source_component='content_viewer', extra=...)`；
    - 调用 `link_processor.process_link(ctx)`；
    - 记录导航日志和解析结果；
    - 调用 `_execute_link_action(result)`。

- `_execute_link_action(result)`：
  - 保持既有动作分发策略：
    - `open_markdown_in_tree` / `open_file`：打开 Markdown / 目标文件；
    - `open_browser` / `open_external`：调用 `QDesktopServices.openUrl` 打开外部链接；
    - `scroll_to_anchor`：通过 JS 滚动至锚点；
    - `open_directory`：优先生找目录下的 `README.md`，否则渲染目录索引页；
  - 不在 T014-00 中新增新的 action 类型或改变既有含义。

---

## 5. 测试与验证计划

### 5.1 单元测试：wiring 覆盖

在无 GUI 环境下，针对 `_CVPage` 的核心 wiring 添加最小单测：

- **UT1：`LPCLICK` → `_handle_lpclick`**

  - 环境：使用 `_WEBENGINE_AVAILABLE == False` 场景下的 `_CVPage` stub；
  - 准备：
    - 构造一个 owner stub，提供 `_handle_lpclick` 方法，将入参 href 记录到属性（如 `last_href`）；
    - 实例化 `_CVPage(owner)`；
  - 执行：
    - 调用 `page.javaScriptConsoleMessage(level=0, message='LPCLICK:/foo/bar', lineNumber=0, sourceID='test')`；
  - 断言：
    - `owner.last_href == '/foo/bar'`。

- **UT2：`acceptNavigationRequest` → `_handle_lpclick`**

  - 环境：同样使用 stub `_CVPage`；
  - 准备：
    - 构造一个简单 url stub，`str(url)` 返回 `'/foo/bar.md'`；
    - owner stub 与 UT1 类似；
  - 执行：
    - 调用 `page.acceptNavigationRequest(url, nav_type='NavigationTypeLinkClicked', isMainFrame=True)`；
  - 断言：
    - `owner.last_href` 为 `'/foo/bar.md'`；
    - 函数返回值为 False。

> 说明：在真实 Qt 环境下，`nav_type` 为 `QWebEnginePage.NavigationTypeLinkClicked`，单测可用字符串或简单枚举 stub 替代，关注“分支与行为”而非 Qt 常量本身。

### 5.2 手工验证：针对 LAD_Project/README.md

在完整 GUI 环境中（非测试模式）：

1. 打开 `LAD_Project/README.md`：
   - 日志中可以看到 `本次渲染HTML包含链接数: N`；
2. 依次点击：
   - 外部链接（如 GitHub / 文档站点）；
   - 指向其它 Markdown 文件的相对链接；
   - 指向子目录的链接；
   - 文内锚点链接；
3. 验证：
   - 对于每一次点击：
     - 日志中应有 `_on_js_console_message` 打印（如 `lpviewer:` 或 `LPCLICK:`）；
     - 随后应看到 `NAV|click_href=...` 与 `NAV|resolved_target=...`；
     - 根据 `action` 不同，界面出现对应行为（打开文件、目录索引、锚点滚动、外部浏览器等）。

### 5.3 与现有测试的关系

- 不修改以下既有测试的调用方式与断言：
  - `tests/test_content_viewer_integration.py` 中基于 `handle_link_click` 的测试；
  - `tests/test_link_processor_misc.py` 中直连 `LinkProcessor` 的测试；
- 新增 wiring 单测只会**增加覆盖面**，不会改变既有测试的语义或期望结果。

---

## 6. 风险评估与回退策略

### 6.1 潜在风险

- **R1：特殊 HTML 场景**  
  某些 HTML 文档可能依赖浏览器本身的导航行为（而非应用层 LinkProcessor）。

  - 当前假设（H3）：
    - 所有来自 README/Markdown 等文档中的链接，期望统一由 LinkProcessor 控制；
    - 在本应用的主使用场景下，这一假设是成立的。

- **R2：Qt 版本差异**  
  不同系统或 QtWebEngine 版本对 `javaScriptConsoleMessage` / `acceptNavigationRequest` 的触发时机和参数格式可能略有差异。

### 6.2 缓解与回退

- 对于 R1：
  - 如后续发现确实存在需“允许原生导航”的个别场景，可在 T014-01 或之后的子任务中：
    - 在 `LinkProcessor` 或 `_execute_link_action` 中引入显式的 `pass_through` / `allow_native_navigation` 动作类型；
    - 在该动作下，允许 WebView 或系统默认处理导航；
  - T014-00 只关注主流 Markdown / README 使用场景，不提前支撑所有特例。

- 对于 R2：
  - 依托 UT1 / UT2 锁定 Python 侧 wiring 行为；
  - GUI 实测中如发现部分平台 `acceptNavigationRequest` 行为异常，可通过配置开关按平台降级为仅依赖 JS+LPCLICK 的模式（该降级方案暂不在 T014-00 的默认范围内，仅作为兜底思路记录）。

---

## 7. 与 LAD-IMPL-014/015 及 integration.qa 的关系

### 7.1 在 014/015 任务树中的位置

- 本方案对应 LAD-IMPL-014 的前置子任务：

  - **T014-00：链接点击基础链路修复**
    - 目标：保证主应用中所有 README / Markdown 内链接点击都能可靠地触发 LinkProcessor，并执行导航。
    - 性质：014 的基础能力修复，与 012/013/014/015 系列任务共同依赖。

- 后续 014 子任务（示例）：
  - T014-01：UI 行为与状态提示文案优化；
  - T014-02：链接相关性能与体验指标（耗时、错误率）采集；
  - T014-03：链接相关配置与热更新体验验证。

### 7.2 与 LAD-IMPL-015 的关系

- 015 关注自动化诊断框架与多数据源接入：
  - integration.qa 报告；
  - 性能/稳定性度量；
  - 日志与运行时事件等。

- 在 T014-00 完成后：
  - 链接点击相关的 NAV 日志与错误事件将更稳定、结构更清晰；
  - 015 可以在后续子任务中考虑：
    - 将链接失败率、解析错误等纳入诊断指标体系；
    - 但这部分设计不在 T014-00 的范围内，仅作为后续可用资产。

### 7.3 与 integration.qa 的关系

- integration.qa 目前主要聚焦：
  - 集成层行为与性能的回归检测；
  - 报告 JSON 的生成与对比；
- T014-00 本身**不直接**修改 integration.qa 的 runner 或报告结构：
  - 仅在运行时行为上，使「点击链接 → LinkProcessor → 导航」更可靠，为未来的 UI 行为测试和诊断提供前提；
  - 可在后续 014/015 子任务中，酌情引入基于 integration.qa 的「链接行为回归」指标或额外检查。

---

## 8. 推荐的文档引用关系

为便于在整体规划中定位本方案，建议在下列文档中增加对本文件的引用：

- `docs/LAD-IMPL-014/015 与 integration.qa 对齐说明.md`
  - 在 LAD-IMPL-014 相关章节中，增加一条子项：
    - 指明「T014-00 链接点击基础链路修复」作为 014 的前置子任务；
    - 链接到本文件 `docs/LAD-IMPL-014/T014-00 链接点击修复方案.md`，作为详细设计说明。

- `README.md`
  - 可选，在「QA / 014/015 规划」相关小节中增加一句简短说明：
    - 例如在介绍 014 目标的地方，附带一行「链接点击基础链路修复（T014-00）」指向本文件；
    - 具体文案应保持简洁，强调其是 014 的基础能力之一。

> 是否立即在上述文档中增加链接，可由后续 LAD-IMPL-014/015 规划调整时一并决策。本文件当前作为 T014-00 的设计基线与实现参考。
